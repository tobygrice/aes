use std::vec;

use super::constants::{RCON, SBOX};

pub fn expand_key(key: &[u8]) -> Vec<[[u8; 4]; 4]> {
    // Variable names match FIPS-197, NIST specification: https://doi.org/10.6028/NIST.FIPS.197-upd1
    // Nk   The number of 32-bit words comprising the key
    // Nr   The number of rounds. 10, 12, and 14 for AES-128, AES-192, and AES-256, respectively
    // w    The result of the key schedule, an array of words that form round keys
    // Nw   The total number of words generated by the key schedule (including initial key)

    let nk = key.len() / 4; // key size (in 4-byte words)
    let nr = nk + 6; // number of rounds = num of words in key + 6
    let nw = (nr + 1) * 4; // total number of words resulting from expansion

    assert!(
        matches!(nk, 4 | 6 | 8),
        "Key must be 128, 192, or 256 bits."
    );

    // initialise w, flat vector comprising words of round_keys
    let mut w: Vec<[u8; 4]> = vec![[0u8; 4]; nw];

    // first nk words of w are filled with the initial key
    for i in 0..key.len() {
        w[i / 4][i % 4] = key[i];
    }

    // initialise temp variable
    let mut temp = w[nk - 1];
    for i in nk..nw {
        if i % nk == 0 {
            // calculate rot_word, sub_word, and rcon on temp
            temp = [
                SBOX[temp[1] as usize] ^ RCON[i / nk],
                SBOX[temp[2] as usize],
                SBOX[temp[3] as usize],
                SBOX[temp[0] as usize],
            ];
        } else if nk == 8 && i % nk == 4 {
            // additional substitution on temp for AES-256 only
            temp = [
                SBOX[temp[0] as usize],
                SBOX[temp[1] as usize],
                SBOX[temp[2] as usize],
                SBOX[temp[3] as usize],
            ];
        }

        // w[i] = temp ⊕ w[i − Nk]
        w[i] = xor_words(&temp, &w[i - nk]);
        temp = w[i]; // update temp
    }

    // convert flat words vector into indexable round_keys vector
    let mut round_keys: Vec<[[u8; 4]; 4]> = vec![[[0u8; 4]; 4]; nr + 1];
    for i in 0..nw {
        round_keys[i / 4][i % 4] = w[i];
    }
    round_keys
}

pub fn add_round_key(state: &mut [[u8; 4]; 4], round_key: &[[u8; 4]; 4]) {
    for i in 0..4 {
        state[i] = xor_words(&state[i], &round_key[i]);
    }
}

// Multiplication in the Galois finite field GF(2^8)
// - adapted from https://crypto.stackexchange.com/a/71206
// - unfortunately, Rust doesn't allow such pretty bit manipulation on u8s,
//   so the translation is not as clean
pub fn gf_mul(mut a: u8, mut b: u8) -> u8 {
    let mut p: u8 = 0;
    while b > 0 {
        if (b & 1) != 0 {
            p ^= a; // add a to p if the lowest bit of b is set
        }

        // multiply a by 2 in the Galois finite field
        // overflow -> reduce modulo GF(2^8) polynomial x^8 + x^4 + x^3 + x + 1
        // ^= 0x1B after shifting
        let hi = a & 0x80;
        a <<= 1; // multiply by 2
        if hi != 0 {
            a ^= 0x1B; // reduce if overflow
        }

        b >>= 1;
    }
    p
}

fn xor_words(a: &[u8; 4], b: &[u8; 4]) -> [u8; 4] {
    [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]]
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn key_schedule_128() {
        // run key schedule on 128 bit sample key from FIPS-197 Appendix A.1
        let key_128: [u8; 16] = [
            0x2b, 0x7e, 0x15, 0x16,
            0x28, 0xae, 0xd2, 0xa6,
            0xab, 0xf7, 0x15, 0x88,
            0x09, 0xcf, 0x4f, 0x3c,
        ];

        let round_keys = expand_key(&key_128);
        let last = *round_keys.last().expect("round_keys should not be empty");

        // compare with last round key of sample schedule in A.1
        let expected: [[u8; 4]; 4] = [
            [0xd0, 0x14, 0xf9, 0xa8],
            [0xc9, 0xee, 0x25, 0x89],
            [0xe1, 0x3f, 0x0c, 0xc8],
            [0xb6, 0x63, 0x0c, 0xa6],
        ];

        assert_eq!(last, expected);
    }

    #[test]
    fn key_schedule_192() {
        // run key schedule on 192 bit sample key from FIPS-197 Appendix A.2
        let key_192: [u8; 24] = [
            0x8e, 0x73, 0xb0, 0xf7,
            0xda, 0x0e, 0x64, 0x52,
            0xc8, 0x10, 0xf3, 0x2b,
            0x80, 0x90, 0x79, 0xe5,
            0x62, 0xf8, 0xea, 0xd2,
            0x52, 0x2c, 0x6b, 0x7b,
        ];

        let round_keys = expand_key(&key_192);
        let last = *round_keys.last().expect("round_keys should not be empty");

        // compare with last round key of sample schedule in A.2
        let expected: [[u8; 4]; 4] = [
            [0xe9, 0x8b, 0xa0, 0x6f],
            [0x44, 0x8c, 0x77, 0x3c],
            [0x8e, 0xcc, 0x72, 0x04],
            [0x01, 0x00, 0x22, 0x02],
        ];

        assert_eq!(last, expected);
    }

    #[test]
    fn key_schedule_256() {
        // run key schedule on 256 bit sample key from FIPS-197 Appendix A.3
        let key_256: [u8; 32] = [
            0x60, 0x3d, 0xeb, 0x10,
            0x15, 0xca, 0x71, 0xbe,
            0x2b, 0x73, 0xae, 0xf0,
            0x85, 0x7d, 0x77, 0x81,
            0x1f, 0x35, 0x2c, 0x07,
            0x3b, 0x61, 0x08, 0xd7,
            0x2d, 0x98, 0x10, 0xa3,
            0x09, 0x14, 0xdf, 0xf4,
        ];

        let round_keys = expand_key(&key_256);
        let last = *round_keys.last().expect("round_keys should not be empty");

        // compare with last round key of sample schedule in A.3
        let expected: [[u8; 4]; 4] = [
            [0xfe, 0x48, 0x90, 0xd1],
            [0xe6, 0x18, 0x8d, 0x0b],
            [0x04, 0x6d, 0xf3, 0x44],
            [0x70, 0x6c, 0x63, 0x1e],
        ];

        assert_eq!(last, expected);
    }
}
